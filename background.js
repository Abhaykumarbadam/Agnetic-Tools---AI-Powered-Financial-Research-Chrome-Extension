importScripts('config.js');
importScripts('api-clients.js');
importScripts('llm-processor.js');

class NotificationManager {
    constructor() {
        this.emailClient = new EmailNotificationClient();
        this.telegramClient = new TelegramClient();
    }

    toSafeString(value) {
        if (value == null) return '';
        if (typeof value === 'string') return value;
        if (typeof value === 'object') {
            if (typeof value.text === 'string') return value.text;
            try { return JSON.stringify(value); } catch { return String(value); }
        }
        return String(value);
    }

    async createNotification(notification, taskId = null) {
        const fallbackDataUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAYAAAA71pVKAAAACXBIWXMAAAsSAAALEgHS3X78AAAAGUlEQVQoka3KsQkAMAzEwO3/0zLwQkqg0I3sQd6w3g5O7k5kZgBqN1bS0h0i8gAAAABJRU5ErkJggg==';
        try {
            if (!chrome?.notifications?.create) {
                console.warn('Notifications API unavailable; skipping notification');
                return;
            }

            const iconUrl = fallbackDataUrl;

            const titleRaw = this.toSafeString(notification.title || 'Agnetic Tools');
            const messageRaw = this.toSafeString(notification.message || '');
            const title = (titleRaw && titleRaw.trim()) ? titleRaw : 'Agnetic Tools';
            const message = (messageRaw && messageRaw.trim()) ? messageRaw : ' ';
            const createAsync = (opts) => new Promise((resolve) => {
                try {
                    chrome.notifications.create(opts, () => resolve());
                } catch (_) {
                    // Synchronous failure (rare); resolve to allow retry
                    resolve();
                }
            });

            await createAsync({
                type: 'basic',
                iconUrl,
                title,
                message,
                contextMessage: taskId ? `Task ID: ${taskId}` : ''
            });

            // If something still went wrong, attempt a minimal fallback
        } catch (error) {
            try {
                if (chrome?.notifications?.create) {
                    await new Promise((resolve) => {
                        try {
                            chrome.notifications.create({
                                type: 'basic',
                                iconUrl: fallbackDataUrl,
                                title: 'Agentic AI Monitor',
                                message: ' ',
                                contextMessage: taskId ? `Task ID: ${taskId}` : ''
                            }, () => resolve());
                        } catch (_) { resolve(); }
                    });
                }
            } catch (e2) {
                console.error('Error creating notification:', e2);
            }
        }
    }

    async sendNotification(notification, task, settings) {
        // Browser notification (always enabled)
        const safe = {
            ...notification,
            title: this.toSafeString(notification.title || 'Agentic AI Monitor'),
            message: this.toSafeString(notification.message || '')
        };
        await this.createNotification(safe, task?.id || null);

        // Enhanced external notifications based on settings
    const channels = Array.isArray(task?.notificationChannels) ? task.notificationChannels : ['browser'];

        for (const channel of channels) {
            try {
                switch (channel) {
                    case 'email':
                        await this.sendEmailNotification(safe, settings?.notificationEmail);
                        break;
                    case 'telegram':
                        await this.sendTelegramNotification(safe, settings?.telegramBot, settings?.telegramChatId);
                        break;
                }
            } catch (error) {
                console.error(`Error sending ${channel} notification:`, error);
            }
        }
    }

    async sendEmailNotification(notification, emailAddress) {
        if (!emailAddress) return;

        const notificationContent = {
            to: emailAddress,
            subject: `Agentic AI Alert: ${notification.title}`,
            body: `
                ${notification.message}
                
                Time: ${new Date().toLocaleString()}
                Task: ${notification.taskName || 'Unknown'}
                
                This notification was generated by Agentic AI Monitor.
            `
        };

        await this.emailClient.sendNotification(notificationContent);
    }

    async sendTelegramNotification(notification, botToken, chatId) {
        if (!botToken || !chatId) return;

        const title = this.toSafeString(notification.title || 'Alert');
        const msg = this.toSafeString(notification.message || '');
        const message = `ðŸ”” *${title}*\n\n${msg}\n\n_Timestamp: ${new Date().toLocaleString()}_`;
        await this.telegramClient.sendMessage(botToken, chatId, message, 'Markdown');
    }
}

class EmailNotificationClient {
    async sendNotification(notification) {
        // This is a simplified implementation for demonstration
        // In production, you would integrate with an email service like SendGrid, JetForm, or SMTP
        console.log('Email notification would be sent:', {
            to: notification.to,
            subject: notification.subject,
            body: notification.body.substring(0, 100) + '...'
        });
        
        // Example: Integration with email API
        try {
            if (typeof ServiceEmail !== 'undefined') {
                await ServiceEmail.send({
                    to: notification.to,
                    subject: notification.subject,
                    text: notification.body
                });
            }
        } catch (error) {
            console.warn('Email service not available, storing notification for later:', error);
            // Store failed email in a retry queue
            await chrome.storage.local.set({
                'email_queue': (await this.getEmailQueue()).concat([notification])
            });
        }
    }

    async getEmailQueue() {
        const result = await chrome.storage.local.get(['email_queue']);
        return result.email_queue || [];
    }
}

class TelegramClient {
    async sendMessage(botToken, chatId, message, parseMode = 'Markdown') {
        try {
            const response = await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    chat_id: chatId,
                    text: message,
                    parse_mode: parseMode,
                    disable_web_page_preview: true
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Telegram API error: ${errorData.description}`);
            }

            const result = await response.json();
            return result.result;
        } catch (error) {
            console.error('Telegram API error:', error);
            
            // Store failed message for retry
            await this.queueFailedMessage(botToken, chatId, message);
            throw error;
        }
    }

    async queueFailedMessage(botToken, chatId, message) {
        try {
            const result = await chrome.storage.local.get(['telegram_queue']);
            const queue = result.telegram_queue || [];
            
            queue.push({
                botToken,
                chatId,
                message,
                timestamp: Date.now()
            });
            
            // Keep only the most recent 10 failed messages
            if (queue.length > 10) {
                queue.shift();
            }
            
            await chrome.storage.local.set({ 'telegram_queue': queue });
        } catch (error) {
            console.error('Failed to queue Telegram message:', error);
        }
    }

    async retryFailedMessages() {
        const result = await chrome.storage.local.get(['telegram_queue']);
        const queue = result.telegram_queue || [];
        
        for (const messageData of queue) {
            try {
                await this.sendMessage(
                    messageData.botToken,
                    messageData.chatId,
                    messageData.message
                );
            } catch (error) {
                // If still failing, skip this message for now
                break;
            }
        }
        
        // Clear the queue after attempting retries
        await chrome.storage.local.set({ 'telegram_queue': [] });
    }
}

// LLMProcessor is imported from llm-processor.js module

class StorageManager {
    async saveTask(task) {
        try {
            const tasks = await this.getAllTasks();
            const existingIndex = tasks.findIndex(t => t.id === task.id);
            
            if (existingIndex >= 0) {
                tasks[existingIndex] = task;
            } else {
                tasks.push(task);
            }
            
            await chrome.storage.local.set({ 'agentic_tasks': tasks });
        } catch (error) {
            console.error('Error saving task:', error);
        }
    }

    async getAllTasks() {
        try {
            const result = await chrome.storage.local.get(['agentic_tasks']);
            return result.agentic_tasks || [];
        } catch (error) {
            console.error('Error loading tasks:', error);
            return [];
        }
    }

    async deleteTask(taskId) {
        try {
            const tasks = await this.getAllTasks();
            const filteredTasks = tasks.filter(t => t.id !== taskId);
            await chrome.storage.local.set({ 'agentic_tasks': filteredTasks });
        } catch (error) {
            console.error('Error deleting task:', error);
        }
    }

    async getSettings() {
        try {
            const result = await chrome.storage.local.get(['agentic_settings']);
            return result.agentic_settings || {};
        } catch (error) {
            console.error('Error loading settings:', error);
            return {};
        }
    }

    async saveSettings(settings) {
        try {
            await chrome.storage.local.set({ 'agentic_settings': settings });
        } catch (error) {
            console.error('Error saving settings:', error);
        }
    }
}

// Initialize lightweight singletons (no monitoring)
const notifier = new NotificationManager();
const storageManager = new StorageManager();

// Global message handlers (no monitoring/task system)
chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
    if (!msg || !msg.type) return;
    switch (msg.type) {
        case 'SAVE_DETECTED_CONTEXT':
            (async () => {
                try {
                    const key = 'agentic_context_events';
                    const existing = (await chrome.storage.local.get([key]))[key] || [];
                    const entry = { id: Date.now(), kind: 'detected_context', payload: msg.context || {}, url: sender?.url || null, at: new Date().toISOString() };
                    await chrome.storage.local.set({ [key]: [entry, ...existing].slice(0,100) });
                    sendResponse({ ok: true });
                } catch (e) { sendResponse({ ok: false, error: String(e.message||e) }); }
            })();
            return true;
        case 'SAVE_API_DATA':
            (async () => {
                try {
                    const key = 'agentic_api_events';
                    const existing = (await chrome.storage.local.get([key]))[key] || [];
                    const entry = { id: Date.now(), kind: 'api_data', payload: msg.data || {}, url: sender?.url || null, at: new Date().toISOString() };
                    await chrome.storage.local.set({ [key]: [entry, ...existing].slice(0,100) });
                    sendResponse({ ok: true });
                } catch (e) { sendResponse({ ok: false, error: String(e.message||e) }); }
            })();
            return true;
        case 'SELECTION_INTEREST_DETECTED':
            (async () => {
                try {
                    const key = 'agentic_selection_events';
                    const existing = (await chrome.storage.local.get([key]))[key] || [];
                    const entry = { id: Date.now(), kind: 'selection', payload: { text: msg.text, type: msg.type, url: msg.url }, url: sender?.url || null, at: new Date().toISOString() };
                    await chrome.storage.local.set({ [key]: [entry, ...existing].slice(0,100) });
                    sendResponse({ ok: true });
                } catch (e) { sendResponse({ ok: false, error: String(e.message||e) }); }
            })();
            return true;
        case 'SEND_RESEARCH_NOTIFICATION':
            (async () => {
                try {
                    const settings = await storageManager.getSettings();
                    await notifier.sendNotification({
                        type: 'info',
                        title: msg.payload?.title || 'Research',
                        message: msg.payload?.message || ''
                    }, { id: 'ad-hoc', name: 'Ad Hoc Research', notificationChannels: ['browser'] }, settings);
                    sendResponse({ success: true });
                } catch (e) { sendResponse({ success: false, error: String(e.message||e) }); }
            })();
            return true;
        case 'BACKTEST_TASK':
            (async () => {
                try { const data = await backtestSymbol(msg.payload); sendResponse({ ok: true, data }); }
                catch (e) { sendResponse({ ok: false, error: String(e.message||e) }); }
            })();
            return true;
        case 'RUN_RESEARCH':
            (async () => {
                try { const data = await runResearchAgent(msg.payload?.query || ''); sendResponse({ ok: true, data }); }
                catch (e) { sendResponse({ ok: false, error: String(e.message||e) }); }
            })();
            return true;
        case 'RUN_OTT_DIGEST':
            (async () => {
                try { const data = await runOTTAgent(msg.payload || {}); sendResponse({ ok: true, data }); }
                catch (e) { sendResponse({ ok: false, error: String(e.message||e) }); }
            })();
            return true;
        case 'RUN_CALC':
            (async () => {
                try { const data = await runCalcAgent(msg.payload || {}); sendResponse({ ok: true, data }); }
                catch (e) { sendResponse({ ok: false, error: String(e.message||e) }); }
            })();
            return true;
        case 'RUN_QA':
            (async () => {
                try { const data = await runQAAgent(msg.payload?.question || ''); sendResponse({ ok: true, data }); }
                catch (e) { sendResponse({ ok: false, error: String(e.message||e) }); }
            })();
            return true;
        case 'RUN_AGENTIC_BATCH':
            (async () => {
                try { const data = await runAgenticBatch(msg.payload || {}); sendResponse({ ok: true, data }); }
                catch (e) { sendResponse({ ok: false, error: String(e.message||e) }); }
            })();
            return true;
    }
});

async function backtestSymbol({ symbol, operator, threshold, lookbackDays = 120 }) {
    if (!symbol) throw new Error('Symbol required');
    const series = await fetchHistoricalSeries(symbol, lookbackDays);
    if (!series?.length) throw new Error('No historical data');

    const closes = series.map(p => p.close);
    const isUp = /^(>|over|above|greater)$/i.test(operator);
    const isDown = /^(<|under|below|less)$/i.test(operator);
    const meets = p => (isUp ? p > threshold : isDown ? p < threshold : false);

    const signals = [];
    for (let i = 1; i < closes.length; i++) {
        if (!meets(closes[i - 1]) && meets(closes[i])) signals.push(i);
    }

    let wins = 0, totalMove = 0;
    for (const i of signals) {
        const end = Math.min(i + 5, closes.length - 1); // 5-day forward horizon
        const move = (closes[end] - closes[i]) * (isUp ? 1 : -1);
        if (move > 0) wins++;
        totalMove += move;
    }

    const rets = [];
    for (let i = 1; i < closes.length; i++) rets.push((closes[i] - closes[i - 1]) / closes[i - 1]);
    const mean = rets.reduce((a, b) => a + b, 0) / (rets.length || 1);
    const variance = rets.reduce((a, r) => a + (r - mean) * (r - mean), 0) / (rets.length || 1);
    const vol = Math.sqrt(variance) * Math.sqrt(252);

    return {
        stats: {
            symbol,
            lookbackDays,
            signals: signals.length,
            precisionPct: +(signals.length ? (wins / signals.length) * 100 : 0).toFixed(1),
            avg5dMove: +(signals.length ? totalMove / signals.length : 0).toFixed(2),
            volatility: +vol.toFixed(2)
        },
        series: {
            dates: series.map(s => s.date),
            closes
        },
        signals
    };
}

async function fetchHistoricalSeries(symbol, lookbackDays = 120) {
    try {
        const { agentic_settings } = await chrome.storage.local.get(['agentic_settings']);
        const avKey = (typeof CONFIG !== 'undefined' && CONFIG.USE_HARDCODED_CONFIG && CONFIG.STOCK?.alphaVantageKey)
            ? CONFIG.STOCK.alphaVantageKey
            : agentic_settings?.alphaVantageKey;
        if (avKey) {
            const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&symbol=${encodeURIComponent(symbol)}&outputsize=compact&apikey=${avKey}`;
            const r = await fetch(url);
            const j = await r.json();
            const ts = j['Time Series (Daily)'];
            if (ts) {
                const arr = Object.entries(ts).map(([d, v]) => ({ date: d, close: +v['4. close'] }));
                arr.sort((a, b) => new Date(a.date) - new Date(b.date));
                return arr.slice(-lookbackDays);
            }
        }
    } catch (e) {
        console.warn('Alpha Vantage historical fetch failed, falling back:', e);
    }

    // Yahoo Finance fallback (approx last 6 months daily)
    const y = await fetch(`https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(symbol)}?interval=1d&range=6mo`);
    const jj = await y.json();
    const r0 = jj?.chart?.result?.[0];
    const t = r0?.timestamp || [];
    const c = r0?.indicators?.quote?.[0]?.close || [];
    const data = t.map((unix, i) => ({
        date: new Date(unix * 1000).toISOString().slice(0, 10),
        close: +c[i]
    })).filter(p => Number.isFinite(p.close));
    return data.slice(-lookbackDays);
}

// Research Agent: multi-step loop with logs
async function runResearchAgent(query) {
    if (!query || typeof query !== 'string') throw new Error('Query required');
    const logs = [];
    const llm = new LLMProcessor();
    await llm.initialize();
    const stock = new StockDataClient();
    const news = new NewsDataClient();

    // Step 0: extract symbol keywords heuristically
    const sym = (query.match(/\b[A-Z]{1,5}\b/) || [])[0];
    logs.push({ step: 'extract', type: 'heuristic', input: query, output: { symbol: sym || null } });

    // Special-case: simple calculator tasks
    if (/fibonacci/i.test(query) && /(exp|exponential)/i.test(query)) {
        const k = (/first\s+(\d+)/i.exec(query)?.[1] ? parseInt(/first\s+(\d+)/i.exec(query)[1]) : 6) || 6;
        const kk = Math.min(Math.max(k,1),20);
        const calc = computeExpFibSum(kk);
        logs.push({ step: 'calculator', tool: 'computeExpFibSum', input: { k: kk }, output: calc });
        const explanation = `I generated the Fibonacci sequence up to ${calc.k} terms which are ${calc.fib.join(', ')}. I then calculated the exponential of each term resulting in ${calc.values.map(v=>v.toFixed(6)).join(', ')}. Adding these numbers gives a total of ${calc.sum.toFixed(6)} for the sum of exponentials of the first ${calc.k} Fibonacci numbers.`;
        const summary = explanation.replace(/[\-*#>`]/g, '').replace(/\s+/g, ' ').trim();
        await persistLogs(query, sym, logs);
        return { summary, articles: [], logs };
    }

    // Step 1: plan
    const planPrompt = `You are a research planner. User query: "${query}". Create a tiny 3-step plan using tools: (1) news, (2) price history last 30d, (3) short synthesis. Return JSON with steps.`;
    const plan = await llm.makeLLMCall(planPrompt, 'task_understanding');
    logs.push({ step: 'plan', promptType: 'task_understanding', prompt: planPrompt, result: plan });

    // Step 2: tools
    let articles = [];
    if (sym) {
        try { articles = await news.searchForStockNews(sym + ' India'); } catch(e) { logs.push({ step: 'news_error', error: String(e.message||e) }); }
    } else {
        const kw = (query.match(/[A-Za-z]{3,}/g) || []).slice(0,2).join(' ');
        const withCountry = (kw ? kw + ' ' : '') + 'India';
        try { articles = await news.getNews(withCountry || 'stocks India'); } catch(e) { logs.push({ step: 'news_error', error: String(e.message||e) }); }
    }
    const artBrief = articles.slice(0,5).map(a => ({ title: a.title, source: a.source, publishedAt: a.publishedAt }));
    logs.push({ step: 'news', tool: 'NewsDataClient', output: artBrief });

    let history = null;
    if (sym) {
        try { history = await fetchHistoricalSeries(sym, 30); } catch(e) { logs.push({ step: 'history_error', error: String(e.message||e) }); }
    }
    logs.push({ step: 'history', tool: 'fetchHistoricalSeries', output: history ? history.slice(-5) : null });

    // Step 3: synthesize (LLM first, fallback to price-only summary)
    const synthPrompt = `Synthesize a concise research note. Query: ${query}\nSymbol: ${sym || 'N/A'}\nRecent articles: ${JSON.stringify(artBrief)}\nLast 30 closes: ${history ? history.map(x=>x.close).slice(-10).join(', ') : 'N/A'}\nFocus on: recent catalysts, sentiment, and near-term risk. Keep under 120 words.`;
    const synth = await llm.makeLLMCall(synthPrompt, 'data_interpretation');
    logs.push({ step: 'synthesize', promptType: 'data_interpretation', prompt: synthPrompt, result: synth });

    // Build fallback summary if LLM text is missing or news empty
    let summaryText = (synth && (synth.text || synth.summary || synth.result || '')) || '';
    if (!summaryText) {
        let fallback = '';
        if (history && history.length) {
            const closes = history.map(x => x.close);
            const last = closes[closes.length - 1];
            const refIdx = Math.max(0, closes.length - 10);
            const ref = closes[refIdx];
            const changePct = ref ? ((last - ref) / ref) * 100 : 0;
            const min30 = Math.min(...closes);
            const max30 = Math.max(...closes);
            const trend = changePct > 2 ? 'uptrend' : changePct < -2 ? 'downtrend' : 'range-bound';
            const name = sym || 'the asset';
            fallback = `I could not find recent articles, so I prepared a price-only snapshot. Over roughly the past month, ${name} is ${trend}. The latest close is ${last.toFixed(2)}. From 10 sessions ago the move is ${changePct.toFixed(1)} percent. The recent range spans ${min30.toFixed(2)} to ${max30.toFixed(2)}. Without fresh news, near term risk depends on whether price holds this range; watch for a break and follow through before acting.`;
            logs.push({ step: 'fallback_summary', basis: 'price_only', details: { last, changePct: +changePct.toFixed(2), min30, max30, trend } });
        } else {
            fallback = 'I could not access recent news or reliable price history at this moment. Please try again in a minute or adjust the query.';
            logs.push({ step: 'fallback_summary', basis: 'no_data' });
        }
        summaryText = fallback;
    }

    // Persist logs (capped)
    await persistLogs(query, sym, logs);

    const text = summaryText;
    return { summary: typeof text === 'string' ? text : JSON.stringify(text), articles: articles.slice(0,6), logs };
}

// OTT Agent: fetch top OTT series this week using TVMaze (no API key) with news fallback
async function runOTTAgent({ send = false, channel = 'telegram' } = {}) {
    const logs = [];

    // Helper: TVMaze top shows over the last N days by frequency in schedule, tie-break by rating
    async function getTVMazeTopShows(days = 7, country = 'US') {
        const today = new Date();
        const freq = new Map();
        const ratings = new Map();
        for (let i = 0; i < days; i++) {
            const d = new Date(today);
            d.setDate(today.getDate() - i);
            const iso = d.toISOString().slice(0, 10);
            try {
                const url = `https://api.tvmaze.com/schedule?country=${encodeURIComponent(country)}&date=${iso}`;
                const r = await fetch(url);
                const arr = await r.json();
                logs.push({ step: 'tvmaze_schedule', date: iso, count: Array.isArray(arr) ? arr.length : 0 });
                if (!Array.isArray(arr)) continue;
                for (const ep of arr) {
                    const show = ep?.show;
                    const name = show?.name?.trim();
                    if (!name) continue;
                    freq.set(name, (freq.get(name) || 0) + 1);
                    if (show?.rating?.average != null) {
                        const current = ratings.get(name) || [];
                        current.push(show.rating.average);
                        ratings.set(name, current);
                    }
                }
            } catch (e) {
                logs.push({ step: 'tvmaze_error', date: iso, error: String(e.message || e) });
            }
        }
        const scored = Array.from(freq.entries()).map(([name, count]) => {
            const r = ratings.get(name) || [];
            const avg = r.length ? r.reduce((a,b)=>a+b,0)/r.length : 0;
            return { name, count, avgRating: +avg.toFixed(2) };
        });
        scored.sort((a,b) => b.count - a.count || b.avgRating - a.avgRating || a.name.localeCompare(b.name));
        const top = scored.slice(0, 5).map(s => s.name);
        logs.push({ step: 'tvmaze_rank', top });
        return top;
    }

    // Primary: TVMaze
    const country = (typeof CONFIG !== 'undefined' && CONFIG.COUNTRY) ? CONFIG.COUNTRY : 'IN';
    let top = await getTVMazeTopShows(7, country);

    // Fallback: News heuristic if TVMaze yields nothing
    if (!top.length) {
        const news = new NewsDataClient();
        const queries = [
            'top ott series india this week',
            'best netflix india series this week',
            'top amazon prime india series',
            'top hotstar india shows'
        ];
        let articles = [];
        for (const q of queries) {
            try {
                const res = await news.getNews(q, { pageSize: 5 });
                articles.push(...res);
                logs.push({ step: 'news', query: q, count: res.length });
            } catch (e) {
                logs.push({ step: 'news_error', query: q, error: String(e.message||e) });
            }
        }
        const genericStop = /^(what\s*to\s*watch|what's\s*on|icymi|today|this\s*week|streaming\s*tips)/i;
        // Additional filters to avoid irrelevant items (podcasts, transcripts, award races, generic promos)
        const irrelevantPatterns = [
            /transcript/i,
            /podcast/i,
            /interview/i,
            /oscars?/i,
            /emmys?/i,
            /festival/i,
            /revamping|revival|director\b/i,
            /tips|guide|list|icymi/i
        ];
        const freq = new Map();
        for (const a of articles) {
            let title = (a.title || '').replace(/[:\-â€”|].*$/, '').trim();
            if (!title || genericStop.test(title)) continue;
            if (irrelevantPatterns.some(rx => rx.test(title))) continue;
            freq.set(title, (freq.get(title) || 0) + 1);
        }
        top = Array.from(freq.entries()).sort((a,b)=>b[1]-a[1]).slice(0,5).map(([t])=>t);
        logs.push({ step: 'news_rank', top });
    }

    // Build plain sentence without emoji or numbering (UI will display as sentence)
    const countryLabel = country === 'IN' ? 'in India' : `in ${country}`;
    const message = top.length
        ? `This weekâ€™s top OTT series ${countryLabel} are: ${top.join('; ')}.`
        : `No reliable OTT ranking could be computed ${countryLabel} at this time.`;

    // Optionally send via Telegram
    if (send && channel === 'telegram' && top.length) {
        try {
            const settings = await chrome.storage.local.get(['agentic_settings']);
            const botToken = (typeof CONFIG !== 'undefined' && CONFIG.TELEGRAM?.botToken) || settings.agentic_settings?.telegramBot;
            const chatId = (typeof CONFIG !== 'undefined' && CONFIG.TELEGRAM?.chatId) || settings.agentic_settings?.telegramChatId;
            if (!botToken || !chatId) throw new Error('Telegram not configured');
            const tg = new TelegramClient();
            await tg.sendMessage(botToken, chatId, `ðŸ“º Top OTT Series This Week\n\n${top.map((t,i)=>`${i+1}. ${t}`).join('\n')}`, 'Markdown');
            logs.push({ step: 'send', channel: 'telegram', status: 'sent' });
        } catch (e) {
            logs.push({ step: 'send_error', channel: 'telegram', error: String(e.message||e) });
        }
    }

    await persistLogs('OTT digest', null, logs);
    return { summary: message, top, logs };
}

// Calculator tool: sum of exp(Fibonacci(n)) for first k terms
function computeExpFibSum(k=6) {
    const fib = [0,1];
    while (fib.length < k) fib.push(fib[fib.length-1] + fib[fib.length-2]);
    const values = fib.slice(0,k).map(n => Math.exp(n));
    const sum = values.reduce((a,b)=>a+b,0);
    return { k, fib: fib.slice(0,k), values, sum };
}

async function runCalcAgent({ k=6 } = {}) {
    const logs = [];
    const out = computeExpFibSum(k);
    logs.push({ step: 'calculator', tool: 'computeExpFibSum', input: { k }, output: out });
    await persistLogs(`calc exp fib ${k}`, null, logs);
    const explanation = `I first generated the Fibonacci sequence up to ${out.k} terms which are ${out.fib.join(', ')}. I then applied the exponential function to each Fibonacci number which gives ${out.values.map(v=>v.toFixed(6)).join(', ')}. Finally I added up these exponential values to obtain ${out.sum.toFixed(6)}. This provides the sum of e to the power of each Fibonacci number for the first ${out.k} terms.`;
    // Ensure no bullet like characters or markdown markers
    const summary = explanation.replace(/[\-*#>`]/g, '').replace(/\s+/g, ' ').trim();
    return { summary, result: out, logs };
}

async function persistLogs(query, symbol, logs) {
    try {
        const key = 'agentic_logs';
        const raw = (await chrome.storage.local.get([key]))[key];
        const existing = Array.isArray(raw) ? raw : [];
        const newEntry = { id: Date.now(), query, symbol: symbol||null, logs: Array.isArray(logs) ? logs : [], createdAt: new Date().toISOString() };
        const next = [newEntry, ...existing].slice(0, 50);
        await chrome.storage.local.set({ [key]: next });
    } catch (e) {
        console.warn('Failed to persist logs:', e);
    }
}

// Q&A Agent: produce plain, step-by-step idea and solution without special characters
async function runQAAgent(question) {
    if (!question || typeof question !== 'string') throw new Error('Question required');
    const logs = [];
    const llm = new LLMProcessor();
    await llm.initialize();

    const instruct = 'Answer plainly in short sentences. Include the main idea and every step. Do not use bullets or markdown characters. Avoid symbols like *, #, -, >, _, ~, backticks, or pipes.';
    const prompt = `${instruct}\nQuestion: ${question}`;
    const res = await llm.makeLLMCall(prompt, 'data_interpretation');
    logs.push({ step: 'qa_llm', promptType: 'data_interpretation', prompt });

    let text = (res && (res.text || res.summary || res.result || '')) || '';
    if (!text) {
        // Simple heuristic fallback: echo question with strategy steps
        text = `Here is an approach. First restate the question to confirm the goal. Next break the problem into small steps. Then solve each step in order. Finally verify the result and state the answer clearly.`;
        logs.push({ step: 'qa_fallback' });
    }

    // Sanitize to remove markdown or AI-like formatting
    const sanitize = s => String(s).replace(/[\-*#>`_~\[\]\(\)|]{1,}/g, '').replace(/\s+/g, ' ').trim();
    const answer = sanitize(text);

    // Persist logs
    await persistLogs(`QA: ${question}`, null, logs);
    return { answer, logs };
}

// Agentic loop orchestrator: runs Calc, OTT (with send), and Research using iterative LLM-driven steps
async function runAgenticBatch({ calcK = 6, ottSend = true, researchQuery = 'Ola stock news last month' } = {}) {
    const transcript = [];
    // Short-circuit: If the input is OTT-only, run OTT agent directly without LLM planning
    try {
        const q = String(researchQuery || '').toLowerCase();
        const hasOTT = /(\bott\b|series|shows?|netflix|prime|hotstar|jiocinema|sonyliv|zee5)/i.test(q);
        const hasFinanceOrCalc = /(stock|price|nifty|sensex|banknifty|fibonacci|exp|exponential|research|qa|question|sum)/i.test(q);
        if (hasOTT && !hasFinanceOrCalc) {
            const data = await runOTTAgent({ send: ottSend, channel: 'telegram' });
            const sent = Array.isArray(data?.logs) && data.logs.some(l => l.step === 'send' && l.status === 'sent');
            const ottResult = { summary: data.summary, top: data.top, sent };
            const payload = { calcResult: null, ottResult, researchResult: null, transcript: [{ role: 'assistant', content: 'OTT-only request detected; ran OTT agent directly.' }], final: data.summary };
            await persistLogs('Agentic Batch (OTT-only)', null, [{ step: 'agentic_batch', payload }]);
            return payload;
        }
    } catch (_) {}
    const llm = new LLMProcessor();
    await llm.initialize();

    // Helper to append full context prompt each turn
    const ask = async (instruction) => {
        const history = transcript.map(t => `${t.role.toUpperCase()}: ${t.content}`).join('\n---\n');
        const prompt = `You are orchestrating tools to complete tasks. Maintain strict context carryover.\n\nHistory so far:\n${history}\n\nNew instruction:\n${instruction}\n\nReturn a short plan (1-2 lines) and which tool to call next as JSON: {"tool":"calc|ott|research|finish","args":{...},"note":"..."}`;
        const res = await llm.makeLLMCall(prompt, 'task_understanding');
        const text = res?.text || JSON.stringify(res);
        transcript.push({ role: 'assistant', content: text });
        return res;
    };

    // Seed user intent
    transcript.push({ role: 'user', content: `Tasks:\n1) Calculations: Sum of exponential values of the first ${calcK} Fibonacci numbers.\n2) External Tool: Find the top OTT series this week (India) and send them to me on Telegram/Email.\n3) Multi-step Research: Find news about a stock (e.g., Ola) and link it to its price changes over the last month.\nUse GROK API for LLM reasoning and iterate: Query â†’ LLM Response â†’ Tool Call â†’ Tool Result ... preserving full history in each Query.` });

    // State buckets
    let calcResult = null;
    let ottResult = null;
    let researchResult = null;

    // Deterministic next-step selector used when LLM gives no/invalid decision
    const pickNextTool = () => {
        if (!calcResult) return 'calc';
        if (!ottResult) return 'ott';
        if (!researchResult) return 'research';
        return 'finish';
    };

    // Make at most 6 loop iterations
    for (let step = 0; step < 6; step++) {
        const decision = await ask(`Decide next tool call. If an item is done, move to the next. Prefer order: calc â†’ ott â†’ research â†’ finish.`);
        let tool = (decision?.tool || decision?.next || (decision?.text && /"tool"\s*:\s*"(\w+)"/i.exec(decision.text)?.[1]) || '').toLowerCase();
        let args = decision?.args || {};

        // Validate tool decision; if invalid or redundant, auto-select deterministically
        const valid = ['calc','ott','research','finish'];
        const redundant = (tool === 'calc' && !!calcResult) || (tool === 'ott' && !!ottResult) || (tool === 'research' && !!researchResult);
        const prematureFinish = (tool === 'finish' && !(calcResult && ottResult && researchResult));
        if (!valid.includes(tool) || redundant || prematureFinish) {
            const auto = pickNextTool();
            tool = auto;
            args = tool === 'calc' ? { k: calcK } : tool === 'research' ? { query: researchQuery } : {};
            // Record synthetic assistant decision for traceability
            transcript.push({ role: 'assistant', content: JSON.stringify({ tool, args, note: 'auto-selected by deterministic fallback' }) });
        }

        if (tool === 'calc' && !calcResult) {
            const k = Number.isFinite(+args.k) ? +args.k : calcK;
            const out = computeExpFibSum(k);
            calcResult = { k: out.k, sum: out.sum, fib: out.fib };
            transcript.push({ role: 'tool', content: JSON.stringify({ name: 'calc', args: { k }, result: calcResult }) });
            continue;
        }

        if (tool === 'ott' && !ottResult) {
            const data = await runOTTAgent({ send: ottSend, channel: 'telegram' });
            const sent = Array.isArray(data?.logs) && data.logs.some(l => l.step === 'send' && l.status === 'sent');
            ottResult = { summary: data.summary, top: data.top, sent };
            transcript.push({ role: 'tool', content: JSON.stringify({ name: 'ott', args: { send: ottSend }, result: ottResult }) });
            continue;
        }

        if (tool === 'research' && !researchResult) {
            const q = args.query || researchQuery;
            const data = await runResearchAgent(q);
            researchResult = { summary: data.summary, articles: data.articles };
            transcript.push({ role: 'tool', content: JSON.stringify({ name: 'research', args: { query: q }, result: researchResult }) });
            continue;
        }

        if (tool === 'finish' || (calcResult && ottResult && researchResult)) {
            break;
        }
    }

    // Final consolidation via LLM with full transcript
    const finalHistory = transcript.map(t => `${t.role.toUpperCase()}: ${t.content}`).join('\n---\n');
    const llm2 = new LLMProcessor();
    await llm2.initialize();
    const finalPrompt = `Summarize results clearly in short sentences with no bullets.\n\nTranscript:\n${finalHistory}\n\nReport:\n1) Calc result.\n2) OTT top shows in India and whether sent.\n3) Research summary linking news to last month price. Keep under 150 words total.`;
    const finalRes = await llm2.makeLLMCall(finalPrompt, 'data_interpretation');
    const finalText = (finalRes && (finalRes.text || finalRes.summary || finalRes.result)) || 'Completed tasks using tool results.';

    const payload = { calcResult, ottResult, researchResult, transcript, final: String(finalText).replace(/[\-*#>`_~|]/g, '').trim() };
    await persistLogs('Agentic Batch', null, [{ step: 'agentic_batch', payload }]);
    return payload;
}
